{
  "code": "\nasync function main() {\n  const root = await figma.getNodeByIdAsync(\"62:32\");\n  if (!root) return { error: \"Node '62:32' not found\" };\n\n  const stats = { totalNodes: 0, dedupedTextNodes: 0, imageNodes: 0, frameNodes: 0, textNodes: 0 };\n  const unresolvedImages = [];\n  const seenImageHashes = new Set();\n  const exportedImages = {};\n  const rasterQueue = []; // [{irNode, figmaNode}] — nodes needing rasterization\n  const HIDE_TEXT_MODE = 'all';\n\n  // ── Dynamic Text Classification (SSOT — generated from figma-forge-shared) ──\n  \n  var _dynNamePats = [/^price/i, /^unit/i, /^socket/i, /^stats/i, /^timer/i, /^count/i, /^amount/i, /^level/i, /^score/i, /^currency/i, /^health/i, /^progress/i, /^rank/i, /^value/i, /^quantity/i];\n  var _dynTextPats = [/^\\{.+\\}$/, /^\\$[\\d.,]+[KMBkmb]?$/, /^[\\d,]+$/, /^\\d+:\\d+$/, /^x[\\d.]+$/i, /^Level \\d+$/i, /^Lv\\.?\\d+$/i, /^Player ?Name$/i, /^0$/, /^\\d+%$/, /^\\.\\.\\./, /→/, /^\\p{Emoji}+$/u, /^\\?$/];\n\n  function isDynText(n) {\n    if (n.type !== 'TEXT') return false;\n    if (n.name.startsWith('$')) return true;\n    if (_dynNamePats.some(function(p) { return p.test(n.name); })) return true;\n    var text = (n.characters || '').trim();\n    if (!text) return false;\n    return _dynTextPats.some(function(p) { return p.test(text); });\n  }\n\n  function hasDescDynamic(n) {\n    if (isDynText(n)) return true;\n    if ('children' in n && n.children) {\n      for (var di = 0; di < n.children.length; di++) {\n        if (hasDescDynamic(n.children[di])) return true;\n      }\n    }\n    return false;\n  }\n\n  function hasDescText(n) {\n    if (n.type === 'TEXT') return true;\n    if ('children' in n && n.children) {\n      for (var di = 0; di < n.children.length; di++) {\n        if (hasDescText(n.children[di])) return true;\n      }\n    }\n    return false;\n  }\n\n  // ── Helpers ──\n  function uint8ToBase64(bytes) {\n    const CHUNK = 8192;\n    const parts = [];\n    for (let i = 0; i < bytes.length; i += CHUNK) {\n      const chunk = bytes.slice(i, i + CHUNK);\n      let binary = '';\n      for (let j = 0; j < chunk.length; j++) {\n        binary += String.fromCharCode(chunk[j]);\n      }\n      parts.push(binary);\n    }\n    const raw = parts.join('');\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    let result = '';\n    let i = 0;\n    while (i < raw.length) {\n      const a = raw.charCodeAt(i++);\n      const b = i < raw.length ? raw.charCodeAt(i++) : 0;\n      const c = i < raw.length ? raw.charCodeAt(i++) : 0;\n      const n = (a << 16) | (b << 8) | c;\n      result += chars[(n >> 18) & 63];\n      result += chars[(n >> 12) & 63];\n      result += (i - 2 < raw.length) ? chars[(n >> 6) & 63] : '=';\n      result += (i - 1 < raw.length) ? chars[n & 63] : '=';\n    }\n    return result;\n  }\n\n  function hasNonLinearGradient(fills) {\n    if (!fills) return false;\n    for (const f of fills) {\n      if (f.visible !== false && (f.type === 'GRADIENT_RADIAL' || f.type === 'GRADIENT_ANGULAR')) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function serializeColor(c) {\n    if (!c) return { r: 0, g: 0, b: 0, a: 1 };\n    return { r: c.r, g: c.g, b: c.b, a: c.a !== undefined ? c.a : 1 };\n  }\n\n  function serializeFill(f) {\n    const fill = {\n      type: f.type,\n      visible: f.visible !== false,\n      opacity: f.opacity !== undefined ? f.opacity : 1,\n    };\n    if (f.type === 'SOLID' && f.color) {\n      fill.color = serializeColor(f.color);\n      fill.color.a = fill.opacity;\n    }\n    if (f.gradientStops) {\n      fill.gradientStops = f.gradientStops.map(s => ({\n        position: s.position,\n        color: serializeColor(s.color),\n      }));\n    }\n    if (f.gradientTransform) {\n      fill.gradientTransform = f.gradientTransform;\n    }\n    if (f.type === 'IMAGE') {\n      fill.imageHash = f.imageHash || null;\n      fill.scaleMode = f.scaleMode || 'FILL';\n      if (f.imageHash && !seenImageHashes.has(f.imageHash)) {\n        seenImageHashes.add(f.imageHash);\n        unresolvedImages.push(f.imageHash);\n      }\n      stats.imageNodes++;\n    }\n    return fill;\n  }\n\n  function serializeStroke(s) {\n    return {\n      type: s.type,\n      visible: s.visible !== false,\n      color: s.color ? serializeColor(s.color) : undefined,\n      gradientStops: s.gradientStops ? s.gradientStops.map(gs => ({\n        position: gs.position,\n        color: serializeColor(gs.color),\n      })) : undefined,\n    };\n  }\n\n  function serializeEffect(e) {\n    return {\n      type: e.type,\n      visible: e.visible !== false,\n      radius: e.radius ?? 0,\n      color: e.color ? serializeColor(e.color) : undefined,\n      offset: e.offset ? { x: e.offset.x, y: e.offset.y } : undefined,\n      spread: e.spread ?? 0,\n    };\n  }\n\n  function serializeTextStyle(node) {\n    // Handle mixed styles by reading from the node directly\n    const style = {};\n    try {\n      style.fontFamily = node.fontName && node.fontName !== figma.mixed ? node.fontName.family : 'Inter';\n      style.fontWeight = node.fontWeight && node.fontWeight !== figma.mixed ? node.fontWeight : 400;\n      style.fontStyle = (node.fontName && node.fontName !== figma.mixed && node.fontName.style) \n        ? (node.fontName.style.includes('Italic') ? 'Italic' : 'Normal')\n        : 'Normal';\n      style.fontSize = node.fontSize && node.fontSize !== figma.mixed ? node.fontSize : 14;\n      style.lineHeight = node.lineHeight && node.lineHeight !== figma.mixed\n        ? (node.lineHeight.unit === 'AUTO' ? 'AUTO' : node.lineHeight.value)\n        : 'AUTO';\n      style.letterSpacing = node.letterSpacing && node.letterSpacing !== figma.mixed ? node.letterSpacing.value : 0;\n      style.textAlignHorizontal = node.textAlignHorizontal || 'LEFT';\n      style.textAlignVertical = node.textAlignVertical || 'TOP';\n      style.textDecoration = node.textDecoration && node.textDecoration !== figma.mixed ? node.textDecoration : 'NONE';\n      style.textCase = node.textCase && node.textCase !== figma.mixed ? node.textCase : 'ORIGINAL';\n    } catch (e) {\n      // Fallbacks for mixed styles\n      style.fontFamily = 'Inter';\n      style.fontWeight = 400;\n      style.fontStyle = 'Normal';\n      style.fontSize = 14;\n      style.lineHeight = 'AUTO';\n      style.letterSpacing = 0;\n      style.textAlignHorizontal = 'LEFT';\n      style.textAlignVertical = 'TOP';\n      style.textDecoration = 'NONE';\n      style.textCase = 'ORIGINAL';\n    }\n    return style;\n  }\n\n  function serializeAutoLayout(node) {\n    if (!node.layoutMode || node.layoutMode === 'NONE') return undefined;\n    return {\n      mode: node.layoutMode,\n      itemSpacing: node.itemSpacing ?? 0,\n      counterAxisSpacing: node.counterAxisSpacing ?? 0,\n      paddingTop: node.paddingTop ?? 0,\n      paddingRight: node.paddingRight ?? 0,\n      paddingBottom: node.paddingBottom ?? 0,\n      paddingLeft: node.paddingLeft ?? 0,\n      primaryAxisAlignItems: node.primaryAxisAlignItems ?? 'MIN',\n      counterAxisAlignItems: node.counterAxisAlignItems ?? 'MIN',\n      layoutWrap: node.layoutWrap ?? 'NO_WRAP',\n    };\n  }\n\n  function getCornerRadius(node) {\n    // Check for per-corner radius first\n    if ('topLeftRadius' in node && (\n      node.topLeftRadius !== node.topRightRadius ||\n      node.topLeftRadius !== node.bottomRightRadius ||\n      node.topLeftRadius !== node.bottomLeftRadius\n    )) {\n      return [\n        node.topLeftRadius ?? 0,\n        node.topRightRadius ?? 0,\n        node.bottomRightRadius ?? 0,\n        node.bottomLeftRadius ?? 0,\n      ];\n    }\n    // Uniform or mixed\n    if ('cornerRadius' in node) {\n      return node.cornerRadius === figma.mixed ? 0 : (node.cornerRadius ?? 0);\n    }\n    return 0;\n  }\n\n  function serializeNode(node) {\n    stats.totalNodes++;\n\n    const ir = {\n      id: node.id,\n      name: node.name,\n      type: node.type,\n      visible: node.visible !== false,\n      x: 'x' in node ? Math.round(node.x * 100) / 100 : 0,\n      y: 'y' in node ? Math.round(node.y * 100) / 100 : 0,\n      width: 'width' in node ? Math.round(node.width * 100) / 100 : 0,\n      height: 'height' in node ? Math.round(node.height * 100) / 100 : 0,\n      rotation: 'rotation' in node ? Math.round(node.rotation * 100) / 100 : 0,\n      cornerRadius: getCornerRadius(node),\n      fills: [],\n      strokes: [],\n      strokeWeight: 0,\n      strokeAlign: 'INSIDE',\n      effects: [],\n      opacity: 'opacity' in node ? node.opacity : 1,\n      blendMode: 'blendMode' in node ? node.blendMode : 'NORMAL',\n      clipsContent: 'clipsDescendants' in node ? node.clipsDescendants : ('clipsContent' in node ? node.clipsContent : false),\n      reactions: [],\n      children: [],\n    };\n\n    // ── Serialization of Properties ──\n    // Fills\n    if ('fills' in node && node.fills && node.fills !== figma.mixed) {\n      ir.fills = Array.from(node.fills).map(serializeFill);\n    }\n\n    // Strokes\n    if ('strokes' in node && node.strokes) {\n      ir.strokes = Array.from(node.strokes).map(serializeStroke);\n      ir.strokeWeight = node.strokeWeight === figma.mixed ? (node.strokeTopWeight ?? 1) : (node.strokeWeight ?? 0);\n      ir.strokeAlign = node.strokeAlign ?? 'INSIDE';\n    }\n\n    // Effects\n    if ('effects' in node && node.effects) {\n      ir.effects = Array.from(node.effects).map(serializeEffect);\n    }\n\n    // ── Render Bounds (accounts for drop shadows, blurs, etc.) ──\n    // exportAsync captures the visual render including effects, so the PNG\n    // may be larger than node.width/height. We compute the delta so the\n    // assembler can size the ImageLabel to match the actual PNG dimensions.\n    var hasVisibleEffects = ir.effects && ir.effects.some(function(e) {\n      return e.visible && (e.type === 'DROP_SHADOW' || e.type === 'INNER_SHADOW' || e.type === 'LAYER_BLUR');\n    });\n    if (hasVisibleEffects && 'absoluteRenderBounds' in node && node.absoluteRenderBounds && 'absoluteBoundingBox' in node && node.absoluteBoundingBox) {\n      var arb = node.absoluteRenderBounds;\n      var abb = node.absoluteBoundingBox;\n      // Compute how much the render extends beyond the bounding box on each side\n      var extraLeft = Math.max(0, abb.x - arb.x);\n      var extraTop = Math.max(0, abb.y - arb.y);\n      var renderW = Math.round(arb.width * 100) / 100;\n      var renderH = Math.round(arb.height * 100) / 100;\n      // Only store if render bounds actually differ from node bounds\n      if (Math.abs(renderW - ir.width) > 0.5 || Math.abs(renderH - ir.height) > 0.5) {\n        ir._renderBounds = {\n          x: Math.round((ir.x - extraLeft) * 100) / 100,\n          y: Math.round((ir.y - extraTop) * 100) / 100,\n          width: Math.round(renderW),\n          height: Math.round(renderH),\n        };\n        console.log('[FigmaForge] RenderBounds: ' + node.name + ' node=' + ir.width + 'x' + ir.height + ' render=' + renderW + 'x' + renderH);\n      }\n    }\n\n    // Text-specific\n    if (node.type === 'TEXT') {\n      ir.characters = node.characters || '';\n      ir.textStyle = serializeTextStyle(node);\n      ir.textAutoResize = node.textAutoResize || 'NONE';\n      stats.textNodes++;\n    }\n\n    // Auto Layout\n    if ('layoutMode' in node) {\n      ir.autoLayout = serializeAutoLayout(node);\n    }\n\n    // Layout sizing\n    if ('layoutSizingHorizontal' in node) ir.layoutSizingHorizontal = node.layoutSizingHorizontal || 'FIXED';\n    if ('layoutSizingVertical' in node) ir.layoutSizingVertical = node.layoutSizingVertical || 'FIXED';\n\n    // Track frame nodes\n    if (node.type === 'FRAME' || node.type === 'COMPONENT' || node.type === 'INSTANCE') stats.frameNodes++;\n\n    // ── Layer Slicing Classification ──\n    // Every node is exactly one of: TEXT, CONTAINER, PNG\n    //   TEXT      → TextLabel (ALL text nodes — preserves editability)\n    //   CONTAINER → Frame (any frame with children, preserves hierarchy)\n    //               If it has a visible fill/stroke, also rasterize background (exported with ALL children hidden)\n    //   PNG       → ImageLabel (leaf visuals, [Flatten]-tagged, childless)\n\n    var hasChildren = 'children' in node && node.children && node.children.length > 0;\n    var nodeName = node.name || '';\n    var isFlattenTag = nodeName.includes('[Flatten]') || nodeName.includes('[Raster]') || nodeName.includes('[Flattened]');\n\n    // Check if node has any visible fill or stroke (background that needs to be captured)\n    const visibleFills = node.fills && Array.isArray(node.fills) ? node.fills.filter(function(f) { return f.visible !== false; }) : [];\n    var hasVisibleFill = visibleFills.length > 0;\n    var hasVisibleStroke = (node.strokes && Array.isArray(node.strokes) && node.strokes.length > 0 && (typeof node.strokeWeight === 'symbol' || node.strokeWeight > 0));\n    var hasVisualBackground = hasVisibleFill || hasVisibleStroke;\n\n    // VERY IMPORTANT: _solidFill optimization natively maps simple frames back to Roblox's BackgroundColor3\n    // Removing this will force simple frames to rasterize as images, breaking script logic!\n    if (visibleFills.length === 1 && visibleFills[0].type === 'SOLID' && !hasVisibleStroke && node.type !== 'TEXT' && !isFlattenTag) {\n      if (!ir._solidFill) ir._solidFill = serializeColor(visibleFills[0].color);\n      ir._solidFillOpacity = visibleFills[0].opacity ?? 1;\n      // Because we can represent this 100% losslessly in Roblox as a Frame, we DO NOT need to rasterize a _BG!\n      hasVisualBackground = false; \n    }\n\n    if (node.type === 'TEXT') {\n      // ALL text → TextLabel (assembler emits as TextLabel for code binding)\n      ir._isDynamic = true;\n    } else if (hasChildren && !isFlattenTag) {\n      // Frame with children → CONTAINER (preserves hierarchy)\n      // Any visible fill/stroke → _isHybrid → _BG ImageLabel from rasterized PNG\n      ir._isHybrid = hasVisualBackground;\n      if (hasVisualBackground && 'exportAsync' in node) {\n        rasterQueue.push({ irNode: ir, figmaNode: node });\n        console.log('[FigmaForge] Container+BG (will rasterize): ' + node.name + ' (' + node.id + ')');\n      } else {\n        console.log('[FigmaForge] Container (no-bg): ' + node.name + ' (' + node.id + ')');\n      }\n    } else {\n      // Leaf visual / [Flatten]-tagged → export as single PNG\n      ir._isFlattened = true;\n      if ('exportAsync' in node) {\n        rasterQueue.push({ irNode: ir, figmaNode: node });\n        console.log('[FigmaForge] PNG slice: ' + node.name + ' (' + node.id + ')');\n      }\n    }\n\n    // Clean name tags\n    if (isFlattenTag) {\n      ir.name = ir.name.replace(/[Flatten]s*/g, '').replace(/[Raster]s*/g, '').replace(/[Flattened]s*/g, '').trim();\n    }\n\n    // ── Children Processing ──\n    // Recurse into CONTAINER nodes only — PNG nodes are flattened\n    if ('children' in node && node.children && !ir._isFlattened) {\n      ir.children = [];\n      for (let ci = 0; ci < node.children.length; ci++) {\n        const child = node.children[ci];\n        const serialized = serializeNode(child);\n        if (serialized) {\n          ir.children.push(serialized);\n        }\n      }\n    }\n\n    // Reactions / Prototype interactions  (#15)\n    if ('reactions' in node && node.reactions && node.reactions.length > 0) {\n      ir.reactions = node.reactions.map(function(r) {\n        const reaction = {\n          trigger: { type: r.trigger ? r.trigger.type : 'ON_CLICK' },\n        };\n        if (r.trigger && r.trigger.delay !== undefined) {\n          reaction.trigger.delay = r.trigger.delay;\n        }\n        if (r.action) {\n          reaction.action = {\n            type: r.action.type,\n            destinationId: r.action.destinationId ?? undefined,\n          };\n          if (r.action.transition) {\n            const t = r.action.transition;\n            reaction.action.transition = {\n              type: t.type,\n              duration: t.duration,\n              easing: {\n                type: t.easing ? t.easing.type : 'EASE_IN_AND_OUT',\n              },\n              direction: t.direction ?? undefined,\n            };\n            if (t.easing && t.easing.type === 'CUSTOM_BEZIER' && t.easing.customBezier) {\n              reaction.action.transition.easing.controlPoints = [\n                t.easing.customBezier.x1, t.easing.customBezier.y1,\n                t.easing.customBezier.x2, t.easing.customBezier.y2,\n              ];\n            }\n          }\n        }\n        return reaction;\n      });\n    }\n\n    return ir;\n  }\n\n  const rootIR = serializeNode(root);\n\n  // ── Rasterization Loop (HYBRID AWARE) ──\n  // Phase 1: Always assign raster hashes and record unresolved images\n  for (const { irNode, figmaNode } of rasterQueue) {\n    const hash = 'raster_' + figmaNode.id.replace(/:/g, '_');\n    irNode._rasterizedImageHash = hash;\n    unresolvedImages.push(hash);\n  }\n\n  // Phase 2: Export PNGs (skip if tree-only mode)\n  const SKIP_PNG = false;\n  if (!SKIP_PNG) {\n    for (const { irNode, figmaNode } of rasterQueue) {\n      try {\n        const hiddenNodes = [];\n        if (irNode._isHybrid) {\n          // Hide ALL children so only the background fill/stroke is baked into the PNG.\n          // Children are preserved in the hierarchy and exported as their own separate PNGs.\n          if ('children' in figmaNode && figmaNode.children) {\n            for (const childNode of figmaNode.children) {\n              if (childNode.visible) {\n                childNode.visible = false;\n                hiddenNodes.push(childNode);\n              }\n            }\n          }\n          console.log('[FigmaForge] Hidden ' + hiddenNodes.length + ' children for hybrid: ' + figmaNode.name);\n          // CRITICAL: Figma's render pipeline needs a tick to process visibility changes\n          // before exportAsync captures the frame. Without this, children are still\n          // baked into the exported PNG.\n          await new Promise(function(r) { setTimeout(r, 100); });\n        }\n\n        const pngBytes = await figmaNode.exportAsync({ format: 'PNG', constraint: { type: 'SCALE', value: 2 } });\n        \n        // Restore visibility\n        for (const n of hiddenNodes) {\n          n.visible = true;\n        }\n\n        const hash = irNode._rasterizedImageHash;\n        exportedImages[hash] = uint8ToBase64(pngBytes);\n        console.log('[FigmaForge] Rasterized ' + (irNode._isHybrid ? 'HYBRID' : 'ATOM') + ': ' + figmaNode.name + ' (' + figmaNode.id + ')');\n      } catch (err) {\n        console.error('[FigmaForge] FAILED to rasterize ' + figmaNode.name + ': ' + err.message);\n      }\n    }\n  } else {\n    console.log('[FigmaForge] Tree-only mode — skipped PNG export for ' + rasterQueue.length + ' nodes');\n  }\n\n  return {\n    version: '1.0.0',\n    exportedAt: new Date().toISOString(),\n    sourceFile: figma.root.name,\n    sourceNodeId: root.id,\n    sourceNodeName: root.name,\n    canvasWidth: root.width || 0,\n    canvasHeight: root.height || 0,\n    root: rootIR,\n    unresolvedImages: unresolvedImages,\n    exportedImages: exportedImages,\n    stats: stats,\n  };\n}\nreturn main();\n"
}
