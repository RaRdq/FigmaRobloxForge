
async function main() {
  const root = await figma.getNodeByIdAsync("60:1026");
  if (!root) return { error: "Node '60:1026' not found" };

  const stats = { totalNodes: 0, dedupedTextNodes: 0, imageNodes: 0, frameNodes: 0, textNodes: 0 };
  const unresolvedImages = [];
  const seenImageHashes = new Set();
  const exportedImages = {};
  const rasterQueue = []; // [{irNode, figmaNode}] — nodes needing rasterization
  const HIDE_TEXT_MODE = 'all';

  // ── Dynamic Text Classification (SSOT — generated from figma-forge-shared) ──
  
  var _dynNamePats = [/^price/i, /^unit/i, /^socket/i, /^stats/i, /^timer/i, /^count/i, /^amount/i, /^level/i, /^score/i, /^currency/i, /^health/i, /^progress/i, /^rank/i, /^value/i, /^quantity/i];
  var _dynTextPats = [/^\{.+\}$/, /^\$[\d.,]+[KMBkmb]?$/, /^[\d,]+$/, /^\d+:\d+$/, /^x[\d.]+$/i, /^Level \d+$/i, /^Lv\.?\d+$/i, /^Player ?Name$/i, /^0$/, /^\d+%$/, /^\.\.\./, /→/, /^\p{Emoji}+$/u, /^\?$/];

  function isDynText(n) {
    if (n.type !== 'TEXT') return false;
    if (n.name.startsWith('$')) return true;
    if (_dynNamePats.some(function(p) { return p.test(n.name); })) return true;
    var text = (n.characters || '').trim();
    if (!text) return false;
    return _dynTextPats.some(function(p) { return p.test(text); });
  }

  function hasDescDynamic(n) {
    if (isDynText(n)) return true;
    if ('children' in n && n.children) {
      for (var di = 0; di < n.children.length; di++) {
        if (hasDescDynamic(n.children[di])) return true;
      }
    }
    return false;
  }

  function hasDescText(n) {
    if (n.type === 'TEXT') return true;
    if ('children' in n && n.children) {
      for (var di = 0; di < n.children.length; di++) {
        if (hasDescText(n.children[di])) return true;
      }
    }
    return false;
  }

  // ── Helpers ──
  function uint8ToBase64(bytes) {
    const CHUNK = 8192;
    const parts = [];
    for (let i = 0; i < bytes.length; i += CHUNK) {
      const chunk = bytes.slice(i, i + CHUNK);
      let binary = '';
      for (let j = 0; j < chunk.length; j++) {
        binary += String.fromCharCode(chunk[j]);
      }
      parts.push(binary);
    }
    const raw = parts.join('');
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    let result = '';
    let i = 0;
    while (i < raw.length) {
      const a = raw.charCodeAt(i++);
      const b = i < raw.length ? raw.charCodeAt(i++) : 0;
      const c = i < raw.length ? raw.charCodeAt(i++) : 0;
      const n = (a << 16) | (b << 8) | c;
      result += chars[(n >> 18) & 63];
      result += chars[(n >> 12) & 63];
      result += (i - 2 < raw.length) ? chars[(n >> 6) & 63] : '=';
      result += (i - 1 < raw.length) ? chars[n & 63] : '=';
    }
    return result;
  }

  function hasNonLinearGradient(fills) {
    if (!fills) return false;
    for (const f of fills) {
      if (f.visible !== false && (f.type === 'GRADIENT_RADIAL' || f.type === 'GRADIENT_ANGULAR')) {
        return true;
      }
    }
    return false;
  }

  function serializeColor(c) {
    if (!c) return { r: 0, g: 0, b: 0, a: 1 };
    return { r: c.r, g: c.g, b: c.b, a: c.a !== undefined ? c.a : 1 };
  }

  function serializeFill(f) {
    const fill = {
      type: f.type,
      visible: f.visible !== false,
      opacity: f.opacity !== undefined ? f.opacity : 1,
    };
    if (f.type === 'SOLID' && f.color) {
      fill.color = serializeColor(f.color);
      fill.color.a = fill.opacity;
    }
    if (f.gradientStops) {
      fill.gradientStops = f.gradientStops.map(s => ({
        position: s.position,
        color: serializeColor(s.color),
      }));
    }
    if (f.gradientTransform) {
      fill.gradientTransform = f.gradientTransform;
    }
    if (f.type === 'IMAGE') {
      fill.imageHash = f.imageHash || null;
      fill.scaleMode = f.scaleMode || 'FILL';
      if (f.imageHash && !seenImageHashes.has(f.imageHash)) {
        seenImageHashes.add(f.imageHash);
        unresolvedImages.push(f.imageHash);
      }
      stats.imageNodes++;
    }
    return fill;
  }

  function serializeStroke(s) {
    return {
      type: s.type,
      visible: s.visible !== false,
      color: s.color ? serializeColor(s.color) : undefined,
      gradientStops: s.gradientStops ? s.gradientStops.map(gs => ({
        position: gs.position,
        color: serializeColor(gs.color),
      })) : undefined,
    };
  }

  function serializeEffect(e) {
    return {
      type: e.type,
      visible: e.visible !== false,
      radius: e.radius ?? 0,
      color: e.color ? serializeColor(e.color) : undefined,
      offset: e.offset ? { x: e.offset.x, y: e.offset.y } : undefined,
      spread: e.spread ?? 0,
    };
  }

  function serializeTextStyle(node) {
    // Handle mixed styles by reading from the node directly
    const style = {};
    try {
      style.fontFamily = node.fontName && node.fontName !== figma.mixed ? node.fontName.family : 'Inter';
      style.fontWeight = node.fontWeight && node.fontWeight !== figma.mixed ? node.fontWeight : 400;
      style.fontStyle = (node.fontName && node.fontName !== figma.mixed && node.fontName.style) 
        ? (node.fontName.style.includes('Italic') ? 'Italic' : 'Normal')
        : 'Normal';
      style.fontSize = node.fontSize && node.fontSize !== figma.mixed ? node.fontSize : 14;
      style.lineHeight = node.lineHeight && node.lineHeight !== figma.mixed
        ? (node.lineHeight.unit === 'AUTO' ? 'AUTO' : node.lineHeight.value)
        : 'AUTO';
      style.letterSpacing = node.letterSpacing && node.letterSpacing !== figma.mixed ? node.letterSpacing.value : 0;
      style.textAlignHorizontal = node.textAlignHorizontal || 'LEFT';
      style.textAlignVertical = node.textAlignVertical || 'TOP';
      style.textDecoration = node.textDecoration && node.textDecoration !== figma.mixed ? node.textDecoration : 'NONE';
      style.textCase = node.textCase && node.textCase !== figma.mixed ? node.textCase : 'ORIGINAL';
    } catch (e) {
      // Fallbacks for mixed styles
      style.fontFamily = 'Inter';
      style.fontWeight = 400;
      style.fontStyle = 'Normal';
      style.fontSize = 14;
      style.lineHeight = 'AUTO';
      style.letterSpacing = 0;
      style.textAlignHorizontal = 'LEFT';
      style.textAlignVertical = 'TOP';
      style.textDecoration = 'NONE';
      style.textCase = 'ORIGINAL';
    }
    return style;
  }

  function serializeAutoLayout(node) {
    if (!node.layoutMode || node.layoutMode === 'NONE') return undefined;
    return {
      mode: node.layoutMode,
      itemSpacing: node.itemSpacing ?? 0,
      counterAxisSpacing: node.counterAxisSpacing ?? 0,
      paddingTop: node.paddingTop ?? 0,
      paddingRight: node.paddingRight ?? 0,
      paddingBottom: node.paddingBottom ?? 0,
      paddingLeft: node.paddingLeft ?? 0,
      primaryAxisAlignItems: node.primaryAxisAlignItems ?? 'MIN',
      counterAxisAlignItems: node.counterAxisAlignItems ?? 'MIN',
      layoutWrap: node.layoutWrap ?? 'NO_WRAP',
    };
  }

  function getCornerRadius(node) {
    // Check for per-corner radius first
    if ('topLeftRadius' in node && (
      node.topLeftRadius !== node.topRightRadius ||
      node.topLeftRadius !== node.bottomRightRadius ||
      node.topLeftRadius !== node.bottomLeftRadius
    )) {
      return [
        node.topLeftRadius ?? 0,
        node.topRightRadius ?? 0,
        node.bottomRightRadius ?? 0,
        node.bottomLeftRadius ?? 0,
      ];
    }
    // Uniform or mixed
    if ('cornerRadius' in node) {
      return node.cornerRadius === figma.mixed ? 0 : (node.cornerRadius ?? 0);
    }
    return 0;
  }

  function serializeNode(node, depth) {
    if (depth > 10) return null;
    stats.totalNodes++;

    const ir = {
      id: node.id,
      name: node.name,
      type: node.type,
      visible: node.visible !== false,
      x: 'x' in node ? Math.round(node.x * 100) / 100 : 0,
      y: 'y' in node ? Math.round(node.y * 100) / 100 : 0,
      width: 'width' in node ? Math.round(node.width * 100) / 100 : 0,
      height: 'height' in node ? Math.round(node.height * 100) / 100 : 0,
      rotation: 'rotation' in node ? Math.round(node.rotation * 100) / 100 : 0,
      cornerRadius: getCornerRadius(node),
      fills: [],
      strokes: [],
      strokeWeight: 0,
      strokeAlign: 'INSIDE',
      effects: [],
      opacity: 'opacity' in node ? node.opacity : 1,
      blendMode: 'blendMode' in node ? node.blendMode : 'NORMAL',
      clipsContent: 'clipsDescendants' in node ? node.clipsDescendants : ('clipsContent' in node ? node.clipsContent : false),
      reactions: [],
      children: [],
    };

    // ── Serialization of Properties ──
    // Fills
    if ('fills' in node && node.fills && node.fills !== figma.mixed) {
      ir.fills = Array.from(node.fills).map(serializeFill);
    }

    // Strokes
    if ('strokes' in node && node.strokes) {
      ir.strokes = Array.from(node.strokes).map(serializeStroke);
      ir.strokeWeight = node.strokeWeight === figma.mixed ? (node.strokeTopWeight ?? 1) : (node.strokeWeight ?? 0);
      ir.strokeAlign = node.strokeAlign ?? 'INSIDE';
    }

    // Effects
    if ('effects' in node && node.effects) {
      ir.effects = Array.from(node.effects).map(serializeEffect);
    }

    // ── Render Bounds (accounts for drop shadows, blurs, etc.) ──
    // exportAsync captures the visual render including effects, so the PNG
    // may be larger than node.width/height. We compute the delta so the
    // assembler can size the ImageLabel to match the actual PNG dimensions.
    var hasVisibleEffects = ir.effects && ir.effects.some(function(e) {
      return e.visible && (e.type === 'DROP_SHADOW' || e.type === 'INNER_SHADOW' || e.type === 'LAYER_BLUR');
    });
    if (hasVisibleEffects && 'absoluteRenderBounds' in node && node.absoluteRenderBounds && 'absoluteBoundingBox' in node && node.absoluteBoundingBox) {
      var arb = node.absoluteRenderBounds;
      var abb = node.absoluteBoundingBox;
      // Compute how much the render extends beyond the bounding box on each side
      var extraLeft = Math.max(0, abb.x - arb.x);
      var extraTop = Math.max(0, abb.y - arb.y);
      var renderW = Math.round(arb.width * 100) / 100;
      var renderH = Math.round(arb.height * 100) / 100;
      // Only store if render bounds actually differ from node bounds
      if (Math.abs(renderW - ir.width) > 0.5 || Math.abs(renderH - ir.height) > 0.5) {
        ir._renderBounds = {
          x: Math.round((ir.x - extraLeft) * 100) / 100,
          y: Math.round((ir.y - extraTop) * 100) / 100,
          width: Math.round(renderW),
          height: Math.round(renderH),
        };
        console.log('[FigmaForge] RenderBounds: ' + node.name + ' node=' + ir.width + 'x' + ir.height + ' render=' + renderW + 'x' + renderH);
      }
    }

    // Text-specific
    if (node.type === 'TEXT') {
      ir.characters = node.characters || '';
      ir.textStyle = serializeTextStyle(node);
      ir.textAutoResize = node.textAutoResize || 'NONE';
      stats.textNodes++;
    }

    // Auto Layout
    if ('layoutMode' in node) {
      ir.autoLayout = serializeAutoLayout(node);
    }

    // Layout sizing
    if ('layoutSizingHorizontal' in node) ir.layoutSizingHorizontal = node.layoutSizingHorizontal || 'FIXED';
    if ('layoutSizingVertical' in node) ir.layoutSizingVertical = node.layoutSizingVertical || 'FIXED';

    // Track frame nodes
    if (node.type === 'FRAME' || node.type === 'COMPONENT' || node.type === 'INSTANCE') stats.frameNodes++;

    // ── Layer Slicing Classification ──
    // Every node is exactly one of: TEXT, CONTAINER, PNG
    //   TEXT      → TextLabel (ALL text nodes — preserves editability)
    //   CONTAINER → Frame (any frame with children, preserves hierarchy)
    //               If it has a visible fill/stroke, also rasterize background (exported with ALL children hidden)
    //   PNG       → ImageLabel (leaf visuals, [Flatten]-tagged, childless)

    var hasChildren = 'children' in node && node.children && node.children.length > 0;
    var nodeName = node.name || '';
    var isFlattenTag = nodeName.includes('[Flatten]') || nodeName.includes('[Raster]') || nodeName.includes('[Flattened]');

    // Check if node has any visible fill or stroke (background that needs to be captured)
    var hasVisibleFill = (node.fills && Array.isArray(node.fills) && node.fills.some(function(f) { return f.visible !== false; }));
    var hasVisibleStroke = (node.strokes && Array.isArray(node.strokes) && node.strokes.length > 0 && node.strokeWeight > 0);
    var hasVisualBackground = hasVisibleFill || hasVisibleStroke;

    if (node.type === 'TEXT') {
      // ALL text → TextLabel (assembler emits as TextLabel for code binding)
      ir._isDynamic = true;
    } else if (hasChildren && !isFlattenTag) {
      // Frame with children → CONTAINER (preserves hierarchy)
      // If it has a visual background, also queue it for background-only rasterization
      ir._isHybrid = hasVisualBackground; // only mark hybrid if there's a background to capture
      if (hasVisualBackground && 'exportAsync' in node) {
        // Mark as hybrid so assembler emits underlay ImageLabel + children on top
        ir._isHybrid = true;
        rasterQueue.push({ irNode: ir, figmaNode: node });
        console.log('[FigmaForge] Container+BG: ' + node.name + ' (' + node.id + ')');
      } else {
        console.log('[FigmaForge] Container (no-bg): ' + node.name + ' (' + node.id + ')');
      }
    } else {
      // Leaf visual / [Flatten]-tagged → export as single PNG
      ir._isFlattened = true;
      if ('exportAsync' in node) {
        rasterQueue.push({ irNode: ir, figmaNode: node });
        console.log('[FigmaForge] PNG slice: ' + node.name + ' (' + node.id + ')');
      }
    }

    // Clean name tags
    if (isFlattenTag) {
      ir.name = ir.name.replace(/[Flatten]s*/g, '').replace(/[Raster]s*/g, '').replace(/[Flattened]s*/g, '').trim();
    }

    // ── Children Processing ──
    // Recurse into CONTAINER nodes only — PNG nodes are flattened
    if ('children' in node && node.children && !ir._isFlattened) {
      ir.children = [];
      for (let ci = 0; ci < node.children.length; ci++) {
        const child = node.children[ci];
        const serialized = serializeNode(child, depth + 1);
        if (serialized) {
          ir.children.push(serialized);
        }
      }
    }

    // Reactions / Prototype interactions  (#15)
    if ('reactions' in node && node.reactions && node.reactions.length > 0) {
      ir.reactions = node.reactions.map(function(r) {
        const reaction = {
          trigger: { type: r.trigger ? r.trigger.type : 'ON_CLICK' },
        };
        if (r.trigger && r.trigger.delay !== undefined) {
          reaction.trigger.delay = r.trigger.delay;
        }
        if (r.action) {
          reaction.action = {
            type: r.action.type,
            destinationId: r.action.destinationId ?? undefined,
          };
          if (r.action.transition) {
            const t = r.action.transition;
            reaction.action.transition = {
              type: t.type,
              duration: t.duration,
              easing: {
                type: t.easing ? t.easing.type : 'EASE_IN_AND_OUT',
              },
              direction: t.direction ?? undefined,
            };
            if (t.easing && t.easing.type === 'CUSTOM_BEZIER' && t.easing.customBezier) {
              reaction.action.transition.easing.controlPoints = [
                t.easing.customBezier.x1, t.easing.customBezier.y1,
                t.easing.customBezier.x2, t.easing.customBezier.y2,
              ];
            }
          }
        }
        return reaction;
      });
    }

    return ir;
  }

  const rootIR = serializeNode(root, 0);

  // ── Rasterization Loop (HYBRID AWARE) ──
  // Phase 1: Always assign raster hashes and record unresolved images
  for (const { irNode, figmaNode } of rasterQueue) {
    const hash = 'raster_' + figmaNode.id.replace(/:/g, '_');
    irNode._rasterizedImageHash = hash;
    unresolvedImages.push(hash);
  }

  // Phase 2: Export PNGs (skip if tree-only mode)
  const SKIP_PNG = false;
  if (!SKIP_PNG) {
    for (const { irNode, figmaNode } of rasterQueue) {
      try {
        const hiddenNodes = [];
        if (irNode._isHybrid) {
          // Hide ALL children so only the background fill/stroke is baked into the PNG.
          // Children are preserved in the hierarchy and exported as their own separate PNGs.
          async function hideAllChildren(n) {
            if ('children' in n && n.children) {
              for (const childNode of n.children) {
                if (childNode.visible) {
                  childNode.visible = false;
                  hiddenNodes.push(childNode);
                  // No recursion needed — hiding top-level children is enough
                }
              }
            }
          }
          await hideAllChildren(figmaNode);
        }

        const pngBytes = await figmaNode.exportAsync({ format: 'PNG', constraint: { type: 'SCALE', value: 2 } });
        
        // Restore visibility
        for (const n of hiddenNodes) {
          n.visible = true;
        }

        const hash = irNode._rasterizedImageHash;
        exportedImages[hash] = uint8ToBase64(pngBytes);
        console.log('[FigmaForge] Rasterized ' + (irNode._isHybrid ? 'HYBRID' : 'ATOM') + ': ' + figmaNode.name + ' (' + figmaNode.id + ')');
      } catch (err) {
        console.error('[FigmaForge] FAILED to rasterize ' + figmaNode.name + ': ' + err.message);
      }
    }
  } else {
    console.log('[FigmaForge] Tree-only mode — skipped PNG export for ' + rasterQueue.length + ' nodes');
  }

  return {
    version: '1.0.0',
    exportedAt: new Date().toISOString(),
    sourceFile: figma.root.name,
    sourceNodeId: "60:1026",
    sourceNodeName: root.name,
    canvasWidth: root.width || 0,
    canvasHeight: root.height || 0,
    root: rootIR,
    unresolvedImages: unresolvedImages,
    exportedImages: exportedImages,
    stats: stats,
  };
}
return main();

